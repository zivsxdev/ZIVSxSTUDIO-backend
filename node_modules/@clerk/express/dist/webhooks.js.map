{"version":3,"sources":["../src/webhooks.ts","../src/utils.ts"],"sourcesContent":["/* eslint-disable import/export */\nimport type { VerifyWebhookOptions } from '@clerk/backend/webhooks';\nimport { verifyWebhook as verifyWebhookBase } from '@clerk/backend/webhooks';\nimport type { Request as ExpressRequest } from 'express';\n\nimport { incomingMessageToRequest } from './utils';\n\n// Ordering of exports matter here since\n// we're overriding the base verifyWebhook\nexport * from '@clerk/backend/webhooks';\n\n/**\n * Verifies the authenticity of a webhook request using Svix.\n *\n * @param request - The incoming webhook Express Request object\n * @param options - Optional configuration object\n * @param options.signingSecret - Custom signing secret. If not provided, falls back to CLERK_WEBHOOK_SIGNING_SECRET env variable\n * @throws Will throw an error if the webhook signature verification fails\n * @returns A promise that resolves to the verified webhook event data\n *\n * @example\n * ```typescript\n * import { verifyWebhook } from '@clerk/express/webhooks';\n *\n * app.post('/api/webhooks', async (req, res) => {\n *   try {\n *     const evt = await verifyWebhook(req);\n *     // handle event\n *     res.send('Webhook received');\n *   } catch (err) {\n *     res.status(400).send('Webhook verification failed');\n *   }\n * });\n * ```\n *\n * @see {@link https://clerk.com/docs/webhooks/sync-data} to learn more about syncing Clerk data to your application using webhooks\n */\nexport async function verifyWebhook(req: ExpressRequest, options?: VerifyWebhookOptions) {\n  const webRequest = incomingMessageToRequest(req);\n  // Cloning instead of implementing the body inside incomingMessageToRequest\n  // to make it more predictable\n  // we must pass in body as string not as an Object or Buffer\n  let serializedBody: string;\n  if (typeof req.body === 'string') {\n    serializedBody = req.body;\n  } else if (Buffer.isBuffer(req.body)) {\n    serializedBody = req.body.toString('utf8');\n  } else if (req.body === undefined || req.body === null) {\n    serializedBody = '';\n  } else {\n    try {\n      serializedBody = JSON.stringify(req.body);\n    } catch (error) {\n      throw new Error(`Failed to serialize request body: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  const clonedRequest = new Request(webRequest, {\n    body: serializedBody,\n  });\n  return verifyWebhookBase(clonedRequest, options);\n}\n","import { isTruthy } from '@clerk/shared/underscore';\nimport type { Request as ExpressRequest } from 'express';\n\nimport type { ExpressRequestWithAuth } from './types';\n\nexport const requestHasAuthObject = (req: ExpressRequest): req is ExpressRequestWithAuth => {\n  return 'auth' in req;\n};\n\nexport const loadClientEnv = () => {\n  return {\n    publishableKey: process.env.CLERK_PUBLISHABLE_KEY || '',\n    clerkJSUrl: process.env.CLERK_JS || '',\n    clerkJSVersion: process.env.CLERK_JS_VERSION || '',\n  };\n};\n\nexport const loadApiEnv = () => {\n  return {\n    secretKey: process.env.CLERK_SECRET_KEY || '',\n    machineSecretKey: process.env.CLERK_MACHINE_SECRET_KEY || '',\n    apiUrl: process.env.CLERK_API_URL || 'https://api.clerk.com',\n    apiVersion: process.env.CLERK_API_VERSION || 'v1',\n    domain: process.env.CLERK_DOMAIN || '',\n    proxyUrl: process.env.CLERK_PROXY_URL || '',\n    signInUrl: process.env.CLERK_SIGN_IN_URL || '',\n    isSatellite: isTruthy(process.env.CLERK_IS_SATELLITE),\n    jwtKey: process.env.CLERK_JWT_KEY || '',\n    sdkMetadata: {\n      name: PACKAGE_NAME,\n      version: PACKAGE_VERSION,\n      environment: process.env.NODE_ENV,\n    },\n    telemetry: {\n      disabled: isTruthy(process.env.CLERK_TELEMETRY_DISABLED),\n      debug: isTruthy(process.env.CLERK_TELEMETRY_DEBUG),\n    },\n  };\n};\n\nexport const incomingMessageToRequest = (req: ExpressRequest): Request => {\n  const headers = Object.keys(req.headers).reduce((acc, key) => Object.assign(acc, { [key]: req?.headers[key] }), {});\n  // @ts-ignore Optimistic attempt to get the protocol in case\n  // req extends IncomingMessage in a useful way. No guarantee\n  // it'll work.\n  const protocol = req.connection?.encrypted ? 'https' : 'http';\n  const dummyOriginReqUrl = new URL(req.originalUrl || req.url || '', `${protocol}://clerk-dummy`);\n  return new Request(dummyOriginReqUrl, {\n    method: req.method,\n    headers: new Headers(headers),\n  });\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,sBAAmD;;;ACFnD,wBAAyB;AAwClB,IAAM,2BAA2B,CAAC,QAAiC;AACxE,QAAM,UAAU,OAAO,KAAK,IAAI,OAAO,EAAE,OAAO,CAAC,KAAK,QAAQ,OAAO,OAAO,KAAK,EAAE,CAAC,GAAG,GAAG,KAAK,QAAQ,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;AAIlH,QAAM,WAAW,IAAI,YAAY,YAAY,UAAU;AACvD,QAAM,oBAAoB,IAAI,IAAI,IAAI,eAAe,IAAI,OAAO,IAAI,GAAG,QAAQ,gBAAgB;AAC/F,SAAO,IAAI,QAAQ,mBAAmB;AAAA,IACpC,QAAQ,IAAI;AAAA,IACZ,SAAS,IAAI,QAAQ,OAAO;AAAA,EAC9B,CAAC;AACH;;;AD1CA,6BAAc,oCATd;AAqCA,eAAsB,cAAc,KAAqB,SAAgC;AACvF,QAAM,aAAa,yBAAyB,GAAG;AAI/C,MAAI;AACJ,MAAI,OAAO,IAAI,SAAS,UAAU;AAChC,qBAAiB,IAAI;AAAA,EACvB,WAAW,OAAO,SAAS,IAAI,IAAI,GAAG;AACpC,qBAAiB,IAAI,KAAK,SAAS,MAAM;AAAA,EAC3C,WAAW,IAAI,SAAS,UAAa,IAAI,SAAS,MAAM;AACtD,qBAAiB;AAAA,EACnB,OAAO;AACL,QAAI;AACF,uBAAiB,KAAK,UAAU,IAAI,IAAI;AAAA,IAC1C,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,qCAAqC,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IACjH;AAAA,EACF;AACA,QAAM,gBAAgB,IAAI,QAAQ,YAAY;AAAA,IAC5C,MAAM;AAAA,EACR,CAAC;AACD,aAAO,gBAAAA,eAAkB,eAAe,OAAO;AACjD;","names":["verifyWebhookBase"]}